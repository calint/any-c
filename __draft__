from c use opengl and posix

vec3         { x=0.0 y=0.0 z=0.0 }
vec4         { vec3; t=0.0 }
position     { vec3 }
orientation  { vec3 }
normal       { vec3 }
color        { vec3 }
scale        { vec3 }
lookvec      { vec3 }
texture      {}
context      {}

buffer template T {}


vertices
a vertex
	has
		position
		normal
		color
;

materials
a material
	has
		name
		diffuse, ambient and specular color
		many configurations
	references
		a texture
		a bump map maybe
		many textures
;

rranges 
	have one begin and one end described by integers
	reference a material each
	
	do draw vertices do
		p "draw_render_range: from " from " to " to " using " material.name ;
	;
;

glos 
	have vertices and rranges
	
	do draw context do
		p "draw_glo" ;
		for each read only r in rranges do r draw vertices
//		for each const r in rranges do r draw copy of vertices
		for i c in rranges do
			i draw buffer
			p " counter: " c ;
			for j cc in rranges do
				if cc is 1 return false
				i draw buffer
				j draw buffer
				return true
			;
		;
	;
;

glob {
	position    ;
	orientation ;
	lookvec     ;
	globs       ;
	bits        { add allocated remove free }
	glo         : ref
	other_glo   : glo ref
	other_globs : stack of globs
	
	draw( r : rendctx ref )=glo.draw(r)

	main {
		var g=globs.alloc()
		globs.free(g)
	}
}

global{
	root : glob

	draw {
		printf("draw_global\n")
	}

	main{
		draw()
		
		gl.draw()
		
		glob g
		
		g.glo=glos.ref(0)
		
		var gloref=ref some_glo

		g.glo=ref some_glo
		
		g.glo=glos.copy(0)
		
		g.glo=ref first g in glos where { g.name=="floor" }
		
		g.glo=ref first in glos where { name=="floor" }

		g.glo=copy first g from glos where { g.name=="floor" }

		g.glo=take from glos where { type is new } sort name range 1..4
		
		give g to globs

		take g from globs { name=="floor" || }

		take first t from tasks

		g2 = take first from globs

		glo g{
			.glo{glos.ref(0)}
			.scale{1,1,1}
		}

		glob g.glo{glos.ref(0)}.scale{1,1,1}.draw()

		glob g.glo{glos.ref(0)}.scale{1,1,1}.draw()	
		
		globs.filter{}
				.sort{}
					.range{}
						.table{}
				.			.output{}

				filter  sort  range  table  output
		globs.q({},      {},    {},    {},   {})
		
		g.draw()
		
		g.rendrngs.draw()
	}

}
