vec3 {x=0.0 y=0.0 z=0.0}

vec4 {vec3; t=0.0}

vec4 : vec3 {t=0.0}

position {vec3}

orientation {vec3}

scale {vec3}

lookvec {vec3}

rendctx {}

buffer template typename T {}

dictionary aka kvps is template for typename T {}

dictionary aka kvps template T {}


kvps template T {}

kvps template T {}

material{}



rrange {
	from     : int
	to       : int
	material : ref

	draw (buffer&) {
		printf("draw_render_range\n")
	}
} 

vertex/vertices {
	pos  : vec3
	norm : vec3
	colr : vec3
}

glo {
	vertices;
	rranges;
	
	draw (rendctx&)	{
		printf ("draw_glo\n")
		
		for all const r in rrranges {
			r.draw(buffer)
		}
		
		for i c in rrranges {
			i.draw (buffer)
			printf (" counter:%d",c)
			
			for j cc in rrranges {
				if cc==1 return false
				r.draw (buffer)
				j.draw (buffer)
				true
			}
			
		}
	}
}



glob {
		
	glo : ref
	
	position;
	
	orientation;
	
	lookvec;
	
	globs;
		
	bits { add allocated remove free }
	
	other_globs : stack of globs
	
	other_glo : glo ref
	
	draw(rendctx&)=glo.draw(rendctx)

	main {
		var g=globs.alloc()
		globs.free(g)
	}

}

global{
	root : glob

	draw {
		printf("draw_global\n")
	}

	main{
		draw()
		
		gl.draw()
		
		glob g
		
		g.glo=glos.ref(0)
		
		var gloref=ref some_glo

		g.glo=ref some_glo
		
		g.glo=glos.copy(0)
		
		g.glo=ref first g in glos where { g.name=="floor" }
		
		g.glo=ref first in glos where { name=="floor" }

		g.glo=copy first g from glos where { g.name=="floor" }

		g.glo=take from glos where { type is new } sort name range 1..4
		
		give g to globs

		take g from globs { name=="floor" || }

		take first t from tasks

		g2 = take first from globs

		glo g{
			.glo{glos.ref(0)}
			.scale{1,1,1}
		}

		glob g.glo{glos.ref(0)}.scale{1,1,1}.draw()

		glob g.glo{glos.ref(0)}.scale{1,1,1}.draw()	
		
		globs.filter{}
				.sort{}
					.range{}
						.table{}
				.			.output{}

				filter  sort  range  table  output
		globs.q({},      {},    {},    {},   {})
		
		g.draw()
		
		g.rendrngs.draw()
	}

}
