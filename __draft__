buffer template T {}

vec3         { x=0.0 y=0.0 z=0.0 }
vec4         { vec3; t=0.0 }
position     { vec3 }
orientation  { vec3 }
normal       { vec3 }
color        { vec3 }
scale        { vec3 }
lookvec      { vec3 }
texture      {}
drawctx      {}

vertex/vertices { position; normal; color; }

material {
	name     : cstr
	diffuse  : color
	ambient  : color
	specular : color
	texture  : ref
}

rrange {
	from     : int
	to       : int
	material : ref

	draw (buffer&) {
		printf("draw_render_range: from %d to %d using %s\n",
			from, to, material.name )
	}
} 

glo has
	vertices and rranges
	
	does draw :
		
		p "draw_glo" ;
		
		for all const r in rranges r draw buffer
		
		for i c in rrranges do
			i draw buffer
			p " counter: " c ;
			for j cc in rrranges do
				if cc is 1 return false
				i draw buffer
				j draw buffer
				return true
			;
		;
	;
;

glob {
	position    ;
	orientation ;
	lookvec     ;
	globs       ;
	bits        { add allocated remove free }
	glo         : ref
	other_glo   : glo ref
	other_globs : stack of globs
	
	draw( r : rendctx ref )=glo.draw(r)

	main {
		var g=globs.alloc()
		globs.free(g)
	}
}

global{
	root : glob

	draw {
		printf("draw_global\n")
	}

	main{
		draw()
		
		gl.draw()
		
		glob g
		
		g.glo=glos.ref(0)
		
		var gloref=ref some_glo

		g.glo=ref some_glo
		
		g.glo=glos.copy(0)
		
		g.glo=ref first g in glos where { g.name=="floor" }
		
		g.glo=ref first in glos where { name=="floor" }

		g.glo=copy first g from glos where { g.name=="floor" }

		g.glo=take from glos where { type is new } sort name range 1..4
		
		give g to globs

		take g from globs { name=="floor" || }

		take first t from tasks

		g2 = take first from globs

		glo g{
			.glo{glos.ref(0)}
			.scale{1,1,1}
		}

		glob g.glo{glos.ref(0)}.scale{1,1,1}.draw()

		glob g.glo{glos.ref(0)}.scale{1,1,1}.draw()	
		
		globs.filter{}
				.sort{}
					.range{}
						.table{}
				.			.output{}

				filter  sort  range  table  output
		globs.q({},      {},    {},    {},   {})
		
		g.draw()
		
		g.rendrngs.draw()
	}

}
